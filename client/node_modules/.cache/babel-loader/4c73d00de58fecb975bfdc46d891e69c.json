{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst utils_1 = require(\"../../utils\");\n\nconst struct_1 = require(\"./struct\");\n\nconst contractInterface_1 = require(\"./contractInterface\");\n\nconst enum_1 = require(\"./enum\");\n\nconst typeMapper_1 = require(\"./typeMapper\");\n\nconst endpoint_1 = require(\"./endpoint\");\n\nclass AbiRegistry {\n  constructor() {\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n\n  static create(json) {\n    let registry = new AbiRegistry().extend(json);\n    let remappedRegistry = registry.remapToKnownTypes();\n    return remappedRegistry;\n  }\n\n  extend(json) {\n    json.types = json.types || {}; // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n\n    let iface = contractInterface_1.ContractInterface.fromJSON(json);\n    this.interfaces.push(iface);\n\n    for (const customTypeName in json.types) {\n      let itemJson = json.types[customTypeName];\n      let typeDiscriminant = itemJson.type; // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n\n      itemJson.name = customTypeName;\n      let customType = this.createCustomType(typeDiscriminant, itemJson);\n      this.customTypes.push(customType);\n    }\n\n    this.sortCustomTypesByDependencies();\n    return this;\n  }\n\n  createCustomType(typeDiscriminant, json) {\n    if (typeDiscriminant == \"struct\") {\n      return struct_1.StructType.fromJSON(json);\n    }\n\n    if (typeDiscriminant == \"enum\") {\n      return enum_1.EnumType.fromJSON(json);\n    }\n\n    throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\n  }\n\n  sortCustomTypesByDependencies() {\n    // TODO: Improve consistency of the sorting function (and make sure the sorting is stable): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n    this.customTypes.sort((a, b) => {\n      const bDependsOnA = b.getNamesOfDependencies().indexOf(a.getName()) > -1;\n\n      if (bDependsOnA) {\n        // Sort \"a\" before \"b\".\n        return -1;\n      } // Sort \"b\" before \"a\".\n\n\n      return 1;\n    });\n  }\n\n  getInterface(name) {\n    let result = this.interfaces.find(e => e.name == name);\n    utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\n    return result;\n  }\n\n  getInterfaces(names) {\n    return names.map(name => this.getInterface(name));\n  }\n\n  getStruct(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName));\n    utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\n    return result;\n  }\n\n  getStructs(names) {\n    return names.map(name => this.getStruct(name));\n  }\n\n  getEnum(name) {\n    let result = this.customTypes.find(e => e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName));\n    utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\n    return result;\n  }\n\n  getEnums(names) {\n    return names.map(name => this.getEnum(name));\n  }\n  /**\n   * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)\n   * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n   *\n   * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n   *\n   * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n   * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n   * The result is an equivalent, more explicit ABI registry.\n   */\n\n\n  remapToKnownTypes() {\n    let mapper = new typeMapper_1.TypeMapper([]);\n    let newCustomTypes = [];\n    let newInterfaces = []; // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n\n    for (const type of this.customTypes) {\n      const mappedTyped = mapper.mapType(type);\n      newCustomTypes.push(mappedTyped);\n    } // Then, remap types of all endpoint parameters.\n    // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n\n\n    mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n\n    for (const iface of this.interfaces) {\n      let newEndpoints = [];\n\n      for (const endpoint of iface.endpoints) {\n        newEndpoints.push(mapEndpoint(endpoint, mapper));\n      }\n\n      let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n      newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n    } // Now return the new registry, with all types remapped to known types\n\n\n    let newRegistry = new AbiRegistry();\n    newRegistry.customTypes.push(...newCustomTypes);\n    newRegistry.interfaces.push(...newInterfaces);\n    return newRegistry;\n  }\n\n}\n\nexports.AbiRegistry = AbiRegistry;\n\nfunction mapEndpoint(endpoint, mapper) {\n  let newInput = endpoint.input.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  let newOutput = endpoint.output.map(e => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"mappings":"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","names":["AbiRegistry","constructor","create","json","registry","extend","remappedRegistry","remapToKnownTypes","types","iface","contractInterface_1","fromJSON","interfaces","push","customTypeName","itemJson","typeDiscriminant","type","name","customType","createCustomType","customTypes","sortCustomTypesByDependencies","struct_1","enum_1","errors","ErrTypingSystem","sort","a","b","bDependsOnA","getNamesOfDependencies","indexOf","getName","getInterface","result","find","e","utils_1","getInterfaces","names","map","getStruct","hasExactClass","ClassName","getStructs","getEnum","getEnums","mapper","typeMapper_1","newCustomTypes","newInterfaces","mappedTyped","mapType","newEndpoints","endpoint","endpoints","mapEndpoint","newConstructor","constructorDefinition","newRegistry","exports","newInput","input","endpoint_1","description","newOutput","output","modifiers"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}