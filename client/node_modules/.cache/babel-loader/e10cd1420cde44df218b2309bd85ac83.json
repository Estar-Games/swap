{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tuple = exports.TupleType = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst struct_1 = require(\"./struct\");\n\nconst fields_1 = require(\"./fields\");\n\nconst struct_2 = require(\"./struct\");\n\nclass TupleType extends struct_2.StructType {\n  constructor() {\n    for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      typeParameters[_key] = arguments[_key];\n    }\n\n    super(TupleType.prepareName(typeParameters), TupleType.prepareFieldDefinitions(typeParameters));\n  }\n\n  getClassName() {\n    return TupleType.ClassName;\n  }\n\n  static prepareName(typeParameters) {\n    let fields = typeParameters.map(type => type.toString()).join(\", \");\n    let result = `tuple${fields.length}<${fields}>`;\n    return result;\n  }\n\n  static prepareFieldDefinitions(typeParameters) {\n    let result = typeParameters.map((type, i) => new fields_1.FieldDefinition(prepareFieldName(i), \"anonymous tuple field\", type));\n    return result;\n  }\n\n}\n\nexports.TupleType = TupleType;\nTupleType.ClassName = \"TupleType\";\n\nfunction prepareFieldName(fieldIndex) {\n  return `field${fieldIndex}`;\n} // TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?\n// Or let Tuple be the base class, but have Struct as a specialization of it, \"named tuple\"?\n// Or leave as it is?\n\n\nclass Tuple extends struct_1.Struct {\n  constructor(type, fields) {\n    super(type, fields);\n  }\n\n  getClassName() {\n    return Tuple.ClassName;\n  }\n\n  static fromItems(items) {\n    if (items.length < 1) {\n      // TODO: Define a better error.\n      throw new errors.ErrTypingSystem(\"bad tuple items\");\n    }\n\n    let fieldsTypes = items.map(item => item.getType());\n    let tupleType = new TupleType(...fieldsTypes);\n    let fields = items.map((item, i) => new fields_1.Field(item, prepareFieldName(i)));\n    return new Tuple(tupleType, fields);\n  }\n\n}\n\nexports.Tuple = Tuple;\nTuple.ClassName = \"Tuple\";","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAEA;;AAEA,MAAaA,SAAb,SAA+BC,mBAA/B,CAAyC;EAGrCC,cAAqC;IAAA,kCAAtBC,cAAsB;MAAtBA,cAAsB;IAAA;;IACjC,MAAMH,SAAS,CAACI,WAAV,CAAsBD,cAAtB,CAAN,EAA6CH,SAAS,CAACK,uBAAV,CAAkCF,cAAlC,CAA7C;EACH;;EAEDG,YAAY;IACR,OAAON,SAAS,CAACO,SAAjB;EACH;;EAEyB,OAAXH,WAAW,CAACD,cAAD,EAAuB;IAC7C,IAAIK,MAAM,GAAWL,cAAc,CAACM,GAAf,CAAmBC,IAAI,IAAIA,IAAI,CAACC,QAAL,EAA3B,EAA4CC,IAA5C,CAAiD,IAAjD,CAArB;IACA,IAAIC,MAAM,GAAG,QAAQL,MAAM,CAACM,MAAM,IAAIN,MAAM,GAA5C;IACA,OAAOK,MAAP;EACH;;EAEqC,OAAvBR,uBAAuB,CAACF,cAAD,EAAuB;IACzD,IAAIU,MAAM,GAAGV,cAAc,CAACM,GAAf,CAAmB,CAACC,IAAD,EAAOK,CAAP,KAAa,IAAIC,wBAAJ,CAAoBC,gBAAgB,CAACF,CAAD,CAApC,EAAyC,uBAAzC,EAAkEL,IAAlE,CAAhC,CAAb;IACA,OAAOG,MAAP;EACH;;AApBoC;;AAAzCK;AACWlB,sBAAY,WAAZ;;AAsBX,SAASiB,gBAAT,CAA0BE,UAA1B,EAA4C;EACxC,OAAO,QAAQA,UAAU,EAAzB;AACH,C,CAED;AACA;AACA;;;AACA,MAAaC,KAAb,SAA2BC,eAA3B,CAAiC;EAG7BnB,YAAYQ,IAAZ,EAA6BF,MAA7B,EAA4C;IACxC,MAAME,IAAN,EAAYF,MAAZ;EACH;;EAEDF,YAAY;IACR,OAAOc,KAAK,CAACb,SAAb;EACH;;EAEe,OAATe,SAAS,CAACC,KAAD,EAAoB;IAChC,IAAIA,KAAK,CAACT,MAAN,GAAe,CAAnB,EAAsB;MAClB;MACA,MAAM,IAAIU,MAAM,CAACC,eAAX,CAA2B,iBAA3B,CAAN;IACH;;IAED,IAAIC,WAAW,GAAGH,KAAK,CAACd,GAAN,CAAUkB,IAAI,IAAIA,IAAI,CAACC,OAAL,EAAlB,CAAlB;IACA,IAAIC,SAAS,GAAG,IAAI7B,SAAJ,CAAc,GAAG0B,WAAjB,CAAhB;IACA,IAAIlB,MAAM,GAAGe,KAAK,CAACd,GAAN,CAAU,CAACkB,IAAD,EAAOZ,CAAP,KAAa,IAAIC,cAAJ,CAAUW,IAAV,EAAgBV,gBAAgB,CAACF,CAAD,CAAhC,CAAvB,CAAb;IAEA,OAAO,IAAIK,KAAJ,CAAUS,SAAV,EAAqBrB,MAArB,CAAP;EACH;;AAtB4B;;AAAjCU;AACWE,kBAAY,OAAZ","names":["TupleType","struct_2","constructor","typeParameters","prepareName","prepareFieldDefinitions","getClassName","ClassName","fields","map","type","toString","join","result","length","i","fields_1","prepareFieldName","exports","fieldIndex","Tuple","struct_1","fromItems","items","errors","ErrTypingSystem","fieldsTypes","item","getType","tupleType"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/tuple.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}