{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Fields = exports.Field = exports.FieldDefinition = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst typeExpressionParser_1 = require(\"./typeExpressionParser\");\n\nclass FieldDefinition {\n  constructor(name, description, type) {\n    this.name = name;\n    this.description = description;\n    this.type = type;\n  }\n\n  static fromJSON(json) {\n    let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);\n    return new FieldDefinition(json.name, json.description, parsedType);\n  }\n\n}\n\nexports.FieldDefinition = FieldDefinition;\n\nclass Field {\n  constructor(value) {\n    let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    this.value = value;\n    this.name = name;\n  }\n\n  checkTyping(expectedDefinition) {\n    const actualType = this.value.getType();\n\n    if (!actualType.equals(expectedDefinition.type)) {\n      throw new errors.ErrTypingSystem(`check type of field \"${expectedDefinition.name}; expected: ${expectedDefinition.type}, actual: ${actualType}\"`);\n    }\n\n    if (this.name != expectedDefinition.name) {\n      throw new errors.ErrTypingSystem(`check name of field \"${expectedDefinition.name}\"`);\n    }\n  }\n\n  equals(other) {\n    return this.name == other.name && this.value.equals(other.value);\n  }\n\n}\n\nexports.Field = Field;\n\nclass Fields {\n  static checkTyping(fields, definitions) {\n    if (fields.length != definitions.length) {\n      throw new errors.ErrTypingSystem(\"fields length vs. field definitions length\");\n    }\n\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i];\n      let definition = definitions[i];\n      field.checkTyping(definition);\n    }\n  }\n\n  static equals(actual, expected) {\n    if (actual.length != expected.length) {\n      return false;\n    }\n\n    for (let i = 0; i < actual.length; i++) {\n      let selfField = actual[i];\n      let otherField = expected[i];\n\n      if (!selfField.equals(otherField)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static getNamesOfTypeDependencies(definitions) {\n    const dependencies = [];\n\n    for (const definition of definitions) {\n      dependencies.push(definition.type.getName());\n      dependencies.push(...definition.type.getNamesOfDependencies());\n    }\n\n    return [...new Set(dependencies)];\n  }\n\n}\n\nexports.Fields = Fields;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAGA,MAAaA,eAAb,CAA4B;EAKxBC,YAAYC,IAAZ,EAA0BC,WAA1B,EAA+CC,IAA/C,EAAyD;IACrD,KAAKF,IAAL,GAAYA,IAAZ;IACA,KAAKC,WAAL,GAAmBA,WAAnB;IACA,KAAKC,IAAL,GAAYA,IAAZ;EACH;;EAEc,OAARC,QAAQ,CAACC,IAAD,EAA0D;IACrE,IAAIC,UAAU,GAAG,IAAIC,2CAAJ,GAA2BC,KAA3B,CAAiCH,IAAI,CAACF,IAAtC,CAAjB;IACA,OAAO,IAAIJ,eAAJ,CAAoBM,IAAI,CAACJ,IAAzB,EAA+BI,IAAI,CAACH,WAApC,EAAiDI,UAAjD,CAAP;EACH;;AAduB;;AAA5BG;;AAiBA,MAAaC,KAAb,CAAkB;EAIdV,YAAYW,KAAZ,EAAgD;IAAA,IAAjBV,IAAiB,uEAAF,EAAE;IAC5C,KAAKU,KAAL,GAAaA,KAAb;IACA,KAAKV,IAAL,GAAYA,IAAZ;EACH;;EAEDW,WAAW,CAACC,kBAAD,EAAoC;IAC3C,MAAMC,UAAU,GAAS,KAAKH,KAAL,CAAWI,OAAX,EAAzB;;IAEA,IAAI,CAACD,UAAU,CAACE,MAAX,CAAkBH,kBAAkB,CAACV,IAArC,CAAL,EAAiD;MAC7C,MAAM,IAAIc,MAAM,CAACC,eAAX,CAA2B,wBAAwBL,kBAAkB,CAACZ,IAAI,eAAeY,kBAAkB,CAACV,IAAI,aAAaW,UAAU,GAAvI,CAAN;IACH;;IACD,IAAI,KAAKb,IAAL,IAAaY,kBAAkB,CAACZ,IAApC,EAA0C;MACtC,MAAM,IAAIgB,MAAM,CAACC,eAAX,CAA2B,wBAAwBL,kBAAkB,CAACZ,IAAI,GAA1E,CAAN;IACH;EACJ;;EAEDe,MAAM,CAACG,KAAD,EAAa;IACf,OAAO,KAAKlB,IAAL,IAAakB,KAAK,CAAClB,IAAnB,IAA2B,KAAKU,KAAL,CAAWK,MAAX,CAAkBG,KAAK,CAACR,KAAxB,CAAlC;EACH;;AAtBa;;AAAlBF;;AAyBA,MAAaW,MAAb,CAAmB;EACG,OAAXR,WAAW,CAACS,MAAD,EAAkBC,WAAlB,EAAgD;IAC9D,IAAID,MAAM,CAACE,MAAP,IAAiBD,WAAW,CAACC,MAAjC,EAAyC;MACrC,MAAM,IAAIN,MAAM,CAACC,eAAX,CAA2B,4CAA3B,CAAN;IACH;;IAED,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACE,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;MACpC,IAAIC,KAAK,GAAGJ,MAAM,CAACG,CAAD,CAAlB;MACA,IAAIE,UAAU,GAAGJ,WAAW,CAACE,CAAD,CAA5B;MAEAC,KAAK,CAACb,WAAN,CAAkBc,UAAlB;IACH;EACJ;;EAEY,OAANV,MAAM,CAACW,MAAD,EAA+BC,QAA/B,EAA6D;IACtE,IAAID,MAAM,CAACJ,MAAP,IAAiBK,QAAQ,CAACL,MAA9B,EAAsC;MAClC,OAAO,KAAP;IACH;;IAED,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,MAAM,CAACJ,MAA3B,EAAmCC,CAAC,EAApC,EAAwC;MACpC,IAAIK,SAAS,GAAGF,MAAM,CAACH,CAAD,CAAtB;MACA,IAAIM,UAAU,GAAGF,QAAQ,CAACJ,CAAD,CAAzB;;MAEA,IAAI,CAACK,SAAS,CAACb,MAAV,CAAiBc,UAAjB,CAAL,EAAmC;QAC/B,OAAO,KAAP;MACH;IACJ;;IAED,OAAO,IAAP;EACH;;EAEgC,OAA1BC,0BAA0B,CAACT,WAAD,EAA+B;IAC5D,MAAMU,YAAY,GAAa,EAA/B;;IAEA,KAAK,MAAMN,UAAX,IAAyBJ,WAAzB,EAAsC;MAClCU,YAAY,CAACC,IAAb,CAAkBP,UAAU,CAACvB,IAAX,CAAgB+B,OAAhB,EAAlB;MACAF,YAAY,CAACC,IAAb,CAAkB,GAAGP,UAAU,CAACvB,IAAX,CAAgBgC,sBAAhB,EAArB;IACH;;IAED,OAAO,CAAC,GAAG,IAAIC,GAAJ,CAAQJ,YAAR,CAAJ,CAAP;EACH;;AAxCc;;AAAnBvB","names":["FieldDefinition","constructor","name","description","type","fromJSON","json","parsedType","typeExpressionParser_1","parse","exports","Field","value","checkTyping","expectedDefinition","actualType","getType","equals","errors","ErrTypingSystem","other","Fields","fields","definitions","length","i","field","definition","actual","expected","selfField","otherField","getNamesOfTypeDependencies","dependencies","push","getName","getNamesOfDependencies","Set"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/fields.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}