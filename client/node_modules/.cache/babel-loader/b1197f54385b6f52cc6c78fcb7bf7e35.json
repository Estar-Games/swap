{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeMapper = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst address_1 = require(\"./address\");\n\nconst boolean_1 = require(\"./boolean\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst composite_1 = require(\"./composite\");\n\nconst enum_1 = require(\"./enum\");\n\nconst generic_1 = require(\"./generic\");\n\nconst h256_1 = require(\"./h256\");\n\nconst numerical_1 = require(\"./numerical\");\n\nconst struct_1 = require(\"./struct\");\n\nconst fields_1 = require(\"./fields\");\n\nconst tokenIdentifier_1 = require(\"./tokenIdentifier\");\n\nconst variadic_1 = require(\"./variadic\");\n\nconst algebraic_1 = require(\"./algebraic\");\n\nconst genericArray_1 = require(\"./genericArray\");\n\nconst string_1 = require(\"./string\");\n\nconst tuple_1 = require(\"./tuple\");\n\nconst codeMetadata_1 = require(\"./codeMetadata\");\n\nconst nothing_1 = require(\"./nothing\");\n\nclass TypeMapper {\n  constructor() {\n    let learnedTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this.openTypesFactories = new Map([[\"Option\", function () {\n      return new generic_1.OptionType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"List\", function () {\n      return new generic_1.ListType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], // For the following open generics, we use a slightly different typing than the one defined by elrond-wasm-rs (temporary workaround).\n    [\"VarArgs\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"MultiResultVec\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"variadic\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalArg\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"optional\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalResult\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"multi\", function () {\n      for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n        typeParameters[_key] = arguments[_key];\n      }\n\n      return new composite_1.CompositeType(...typeParameters);\n    }], [\"MultiArg\", function () {\n      for (var _len2 = arguments.length, typeParameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeParameters[_key2] = arguments[_key2];\n      }\n\n      return new composite_1.CompositeType(...typeParameters);\n    }], [\"MultiResult\", function () {\n      for (var _len3 = arguments.length, typeParameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeParameters[_key3] = arguments[_key3];\n      }\n\n      return new composite_1.CompositeType(...typeParameters);\n    }], [\"multi\", function () {\n      for (var _len4 = arguments.length, typeParameters = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeParameters[_key4] = arguments[_key4];\n      }\n\n      return new composite_1.CompositeType(...typeParameters);\n    }], // Perhaps we can adjust the ABI generator to only output \"tuple\", instead of \"tupleN\"?\n    [\"tuple\", function () {\n      for (var _len5 = arguments.length, typeParameters = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeParameters[_key5] = arguments[_key5];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], [\"tuple2\", function () {\n      for (var _len6 = arguments.length, typeParameters = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeParameters[_key6] = arguments[_key6];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], [\"tuple3\", function () {\n      for (var _len7 = arguments.length, typeParameters = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        typeParameters[_key7] = arguments[_key7];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], [\"tuple4\", function () {\n      for (var _len8 = arguments.length, typeParameters = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        typeParameters[_key8] = arguments[_key8];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], [\"tuple5\", function () {\n      for (var _len9 = arguments.length, typeParameters = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        typeParameters[_key9] = arguments[_key9];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], [\"tuple6\", function () {\n      for (var _len10 = arguments.length, typeParameters = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        typeParameters[_key10] = arguments[_key10];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], [\"tuple7\", function () {\n      for (var _len11 = arguments.length, typeParameters = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        typeParameters[_key11] = arguments[_key11];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], [\"tuple8\", function () {\n      for (var _len12 = arguments.length, typeParameters = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        typeParameters[_key12] = arguments[_key12];\n      }\n\n      return new tuple_1.TupleType(...typeParameters);\n    }], // Known-length arrays.\n    // TODO: Handle these in typeExpressionParser!\n    [\"array20\", function () {\n      return new genericArray_1.ArrayVecType(20, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array32\", function () {\n      return new genericArray_1.ArrayVecType(32, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array46\", function () {\n      return new genericArray_1.ArrayVecType(46, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array64\", function () {\n      return new genericArray_1.ArrayVecType(64, arguments.length <= 0 ? undefined : arguments[0]);\n    }]]); // For closed types, we hold actual type instances instead of type constructors / factories (no type parameters needed).\n\n    this.closedTypesMap = new Map([[\"u8\", new numerical_1.U8Type()], [\"u16\", new numerical_1.U16Type()], [\"u32\", new numerical_1.U32Type()], [\"u64\", new numerical_1.U64Type()], [\"U64\", new numerical_1.U64Type()], [\"BigUint\", new numerical_1.BigUIntType()], [\"i8\", new numerical_1.I8Type()], [\"i16\", new numerical_1.I16Type()], [\"i32\", new numerical_1.I32Type()], [\"i64\", new numerical_1.I64Type()], [\"Bigint\", new numerical_1.BigIntType()], [\"BigInt\", new numerical_1.BigIntType()], [\"bool\", new boolean_1.BooleanType()], [\"bytes\", new bytes_1.BytesType()], [\"Address\", new address_1.AddressType()], [\"H256\", new h256_1.H256Type()], [\"utf-8 string\", new string_1.StringType()], [\"TokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()], [\"CodeMetadata\", new codeMetadata_1.CodeMetadataType()], [\"nothing\", new nothing_1.NothingType()], [\"AsyncCall\", new nothing_1.NothingType()]]);\n    this.learnedTypesMap = new Map(); // Boostrap from previously learned types, if any.\n\n    for (const type of learnedTypes) {\n      this.learnedTypesMap.set(type.getName(), type);\n    }\n  }\n\n  mapType(type) {\n    let mappedType = this.mapRecursiveType(type);\n\n    if (mappedType) {\n      // We do not learn generic types (that also have type parameters)\n      if (!mappedType.isGenericType()) {\n        this.learnType(mappedType);\n      }\n\n      return mappedType;\n    }\n\n    throw new errors.ErrTypingSystem(`Cannot map the type \"${type.getName()}\" to a known type`);\n  }\n\n  mapRecursiveType(type) {\n    let isGeneric = type.isGenericType();\n    let previouslyLearnedType = this.learnedTypesMap.get(type.getName());\n\n    if (previouslyLearnedType) {\n      return previouslyLearnedType;\n    }\n\n    let knownClosedType = this.closedTypesMap.get(type.getName());\n\n    if (knownClosedType) {\n      return knownClosedType;\n    }\n\n    if (type.hasExactClass(enum_1.EnumType.ClassName)) {\n      // This will call mapType() recursively, for all the enum variant fields.\n      return this.mapEnumType(type);\n    }\n\n    if (type.hasExactClass(struct_1.StructType.ClassName)) {\n      // This will call mapType() recursively, for all the struct's fields.\n      return this.mapStructType(type);\n    }\n\n    if (isGeneric) {\n      // This will call mapType() recursively, for all the type parameters.\n      return this.mapGenericType(type);\n    }\n\n    return null;\n  }\n\n  learnType(type) {\n    this.learnedTypesMap.delete(type.getName());\n    this.learnedTypesMap.set(type.getName(), type);\n  }\n\n  mapStructType(type) {\n    let mappedFields = this.mappedFields(type.getFieldsDefinitions());\n    let mappedStruct = new struct_1.StructType(type.getName(), mappedFields);\n    return mappedStruct;\n  }\n\n  mapEnumType(type) {\n    let variants = type.variants.map(variant => new enum_1.EnumVariantDefinition(variant.name, variant.discriminant, this.mappedFields(variant.getFieldsDefinitions())));\n    let mappedEnum = new enum_1.EnumType(type.getName(), variants);\n    return mappedEnum;\n  }\n\n  mappedFields(definitions) {\n    return definitions.map(definition => new fields_1.FieldDefinition(definition.name, definition.description, this.mapType(definition.type)));\n  }\n\n  mapGenericType(type) {\n    let typeParameters = type.getTypeParameters();\n    let mappedTypeParameters = typeParameters.map(item => this.mapType(item));\n    let factory = this.openTypesFactories.get(type.getName());\n\n    if (!factory) {\n      throw new errors.ErrTypingSystem(`Cannot map the generic type \"${type.getName()}\" to a known type`);\n    }\n\n    return factory(...mappedTypeParameters);\n  }\n\n}\n\nexports.TypeMapper = TypeMapper;","map":{"version":3,"mappings":"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","names":["TypeMapper","constructor","learnedTypes","openTypesFactories","Map","generic_1","variadic_1","algebraic_1","typeParameters","composite_1","tuple_1","genericArray_1","closedTypesMap","numerical_1","boolean_1","bytes_1","address_1","h256_1","string_1","tokenIdentifier_1","codeMetadata_1","nothing_1","learnedTypesMap","type","set","getName","mapType","mappedType","mapRecursiveType","isGenericType","learnType","errors","ErrTypingSystem","isGeneric","previouslyLearnedType","get","knownClosedType","hasExactClass","enum_1","ClassName","mapEnumType","struct_1","mapStructType","mapGenericType","delete","mappedFields","getFieldsDefinitions","mappedStruct","variants","map","variant","name","discriminant","mappedEnum","definitions","definition","fields_1","description","getTypeParameters","mappedTypeParameters","item","factory","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/typeMapper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}