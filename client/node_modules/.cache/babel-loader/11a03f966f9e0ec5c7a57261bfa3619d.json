{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProvider = void 0;\n\nconst client_1 = __importDefault(require(\"@walletconnect/client\"));\n\nconst constants_1 = require(\"./constants\");\n\nconst logger_1 = require(\"./logger\");\n\nconst errors_1 = require(\"./errors\");\n\nconst signature_1 = require(\"./signature\");\n\nconst userAddress_1 = require(\"./userAddress\");\n\nclass WalletConnectProvider {\n  constructor(walletConnectBridge, onClientConnect) {\n    this.address = \"\";\n    this.signature = \"\";\n    this.walletConnectBridge = walletConnectBridge;\n    this.onClientConnect = onClientConnect;\n  }\n  /**\n   * Initiates wallet connect client.\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.walletConnector = new client_1.default({\n        bridge: this.walletConnectBridge\n      });\n      this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n      this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n      this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n\n      if (this.walletConnector.connected && this.walletConnector.accounts.length) {\n        const [account] = this.walletConnector.accounts;\n        const [address, signature] = account.split(\".\");\n        yield this.loginAccount(address, signature);\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Returns true if init() was previously called successfully\n   */\n\n\n  isInitialized() {\n    return !!this.walletConnector;\n  }\n  /**\n   * Mocked function, returns isInitialized as an async function\n   */\n\n\n  isConnected() {\n    return new Promise((resolve, _) => resolve(this.isInitialized()));\n  }\n\n  login() {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        yield this.init();\n      }\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield this.walletConnector.killSession();\n        logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n        return \"\";\n      }\n\n      yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({\n        chainId: constants_1.WALLETCONNECT_ELROND_CHAIN_ID\n      });\n\n      if (!((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri)) {\n        return \"\";\n      }\n\n      return (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri;\n    });\n  }\n  /**\n   * Mocks a logout request by returning true\n   */\n\n\n  logout() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      if (this.walletConnector.connected) {\n        yield (_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.killSession();\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Fetches the wallet connect address\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      return this.address;\n    });\n  }\n  /**\n   * Fetches the wallet connect signature\n   */\n\n\n  getSignature() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      return this.signature;\n    });\n  }\n  /**\n   * Method will be available once the Maiar wallet connect hook is implemented\n   * @param _\n   */\n\n\n  signMessage(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new errors_1.ErrNotImplemented();\n    });\n  }\n  /**\n   * Signs a transaction and returns it\n   * @param transaction\n   */\n\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const address = yield this.getAddress();\n      const sig = yield this.walletConnector.sendCustomRequest({\n        method: \"erd_sign\",\n        params: this.prepareWalletConnectMessage(transaction, address)\n      });\n\n      if (!sig || !sig.signature) {\n        logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n        throw new Error(\"Wallet Connect could not sign the transaction\");\n      }\n\n      transaction.applySignature(signature_1.Signature.fromHex(sig.signature), userAddress_1.UserAddress.fromBech32(address));\n      return transaction;\n    });\n  }\n  /**\n   * Signs an array of transactions and returns it\n   * @param transactions\n   */\n\n\n  signTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (transactions.length === 1) {\n        const signedTransaction = yield this.signTransaction(transactions[0]);\n        return [signedTransaction];\n      }\n\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const address = yield this.getAddress();\n      const params = transactions.map(transaction => this.prepareWalletConnectMessage(transaction, address));\n      const signatures = yield this.walletConnector.sendCustomRequest({\n        method: \"erd_batch_sign\",\n        params\n      });\n\n      if (!signatures || !Array.isArray(signatures)) {\n        logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n        throw new Error(\"Wallet Connect could not sign the transactions\");\n      }\n\n      if (transactions.length !== signatures.length) {\n        logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n        throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n      }\n\n      for (const [index, transaction] of transactions.entries()) {\n        transaction.applySignature(signature_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));\n      }\n\n      return transactions;\n    });\n  }\n  /**\n   * Sends a custom method and params and returns the response object\n   */\n\n\n  sendCustomMessage(_ref) {\n    let {\n      method,\n      params\n    } = _ref;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.walletConnector) {\n        logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n        throw new Error(\"Wallet Connect not initialised, call init() first\");\n      }\n\n      const customMessageResponse = yield this.walletConnector.sendCustomRequest({\n        method,\n        params\n      });\n\n      if (!customMessageResponse) {\n        logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n        throw new Error(\"Wallet Connect could not send the message\");\n      }\n\n      return customMessageResponse;\n    });\n  }\n\n  onConnect(error, _ref2) {\n    let {\n      params\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (error) {\n        throw error;\n      }\n\n      if (!params || !params[0]) {\n        logger_1.Logger.error(\"Wallet Connect missing payload\");\n        throw new Error(\"missing payload\");\n      }\n\n      const {\n        accounts: [account]\n      } = params[0];\n      const [address, signature] = account.split(\".\");\n      yield this.loginAccount(address, signature);\n    });\n  }\n\n  onDisconnect(error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (error) {\n        throw error;\n      }\n\n      this.onClientConnect.onClientLogout();\n    });\n  }\n\n  loginAccount(address, signature) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.addressIsValid(address)) {\n        this.address = address;\n\n        if (signature) {\n          this.signature = signature;\n        }\n\n        this.onClientConnect.onClientLogin();\n        return;\n      }\n\n      logger_1.Logger.error(`Wallet Connect invalid address ${address}`);\n\n      if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n        yield (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n      }\n    });\n  }\n\n  prepareWalletConnectMessage(transaction, address) {\n    return {\n      nonce: transaction.getNonce().valueOf(),\n      from: address,\n      to: transaction.getReceiver().toString(),\n      amount: transaction.getValue().toString(),\n      gasPrice: transaction.getGasPrice().valueOf().toString(),\n      gasLimit: transaction.getGasLimit().valueOf().toString(),\n      data: Buffer.from(transaction.getData().toString().trim()).toString(),\n      chainId: transaction.getChainID().valueOf(),\n      version: transaction.getVersion().valueOf()\n    };\n  }\n\n  addressIsValid(destinationAddress) {\n    try {\n      const addr = userAddress_1.UserAddress.fromBech32(destinationAddress);\n      return !!addr;\n    } catch (_a) {\n      return false;\n    }\n  }\n\n}\n\nexports.WalletConnectProvider = WalletConnectProvider;","map":{"version":3,"mappings":"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","names":["WalletConnectProvider","constructor","walletConnectBridge","onClientConnect","init","walletConnector","client_1","bridge","on","onConnect","bind","onDisconnect","connected","accounts","length","account","address","signature","split","loginAccount","isInitialized","isConnected","Promise","resolve","_","login","_a","killSession","logger_1","trace","_b","createSession","chainId","constants_1","_c","uri","_d","logout","error","Error","getAddress","getSignature","signMessage","errors_1","signTransaction","transaction","sig","sendCustomRequest","method","params","prepareWalletConnectMessage","applySignature","signature_1","fromHex","userAddress_1","fromBech32","signTransactions","transactions","signedTransaction","map","signatures","Array","isArray","index","entries","sendCustomMessage","customMessageResponse","onClientLogout","addressIsValid","onClientLogin","nonce","getNonce","valueOf","from","to","getReceiver","toString","amount","getValue","gasPrice","getGasPrice","gasLimit","getGasLimit","data","Buffer","getData","trim","getChainID","version","getVersion","destinationAddress","addr","exports"],"sourceRoot":"","sources":["../src/walletConnectProvider.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}