{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionWatcher = void 0;\n\nconst asyncTimer_1 = require(\"./asyncTimer\");\n\nconst logger_1 = require(\"./logger\");\n\nconst errors_1 = require(\"./errors\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\n\n\nclass TransactionWatcher {\n  /**\n   *\n   * @param fetcher The transaction fetcher\n   * @param pollingInterval The polling interval, in milliseconds\n   * @param timeout The timeout, in milliseconds\n   */\n  constructor(fetcher) {\n    let pollingInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionWatcher.DefaultPollingInterval;\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TransactionWatcher.DefaultTimeout;\n    this.fetcher = new TransactionFetcherWithTracing(fetcher);\n    this.pollingInterval = pollingInterval;\n    this.timeout = timeout;\n  }\n  /**\n   * Waits until the transaction reaches the \"pending\" status.\n   */\n\n\n  awaitPending(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const isPending = transaction => transaction.status.isPending();\n\n      const doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.fetcher.getTransaction(transaction.getHash().hex());\n      });\n\n      const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();\n\n      return this.awaitConditionally(isPending, doFetch, errorProvider);\n    });\n  }\n  /**\n    * Waits until the transaction is completely processed.\n    */\n\n\n  awaitCompleted(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const isCompleted = transactionOnNetwork => transactionOnNetwork.isCompleted;\n\n      const doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.fetcher.getTransaction(transaction.getHash().hex());\n      });\n\n      const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();\n\n      return this.awaitConditionally(isCompleted, doFetch, errorProvider);\n    });\n  }\n\n  awaitAllEvents(transaction, events) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const foundAllEvents = transactionOnNetwork => {\n        const allEventIdentifiers = this.getAllTransactionEvents(transactionOnNetwork).map(event => event.identifier);\n        const allAreFound = events.every(event => allEventIdentifiers.includes(event));\n        return allAreFound;\n      };\n\n      const doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.fetcher.getTransaction(transaction.getHash().hex());\n      });\n\n      const errorProvider = () => new errors_1.ErrExpectedTransactionEventsNotFound();\n\n      return this.awaitConditionally(foundAllEvents, doFetch, errorProvider);\n    });\n  }\n\n  awaitAnyEvent(transaction, events) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const foundAnyEvent = transactionOnNetwork => {\n        const allEventIdentifiers = this.getAllTransactionEvents(transactionOnNetwork).map(event => event.identifier);\n        const anyIsFound = events.find(event => allEventIdentifiers.includes(event)) != undefined;\n        return anyIsFound;\n      };\n\n      const doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.fetcher.getTransaction(transaction.getHash().hex());\n      });\n\n      const errorProvider = () => new errors_1.ErrExpectedTransactionEventsNotFound();\n\n      return this.awaitConditionally(foundAnyEvent, doFetch, errorProvider);\n    });\n  }\n\n  awaitOnCondition(transaction, condition) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.fetcher.getTransaction(transaction.getHash().hex());\n      });\n\n      const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();\n\n      return this.awaitConditionally(condition, doFetch, errorProvider);\n    });\n  }\n\n  awaitConditionally(isSatisfied, doFetch, createError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n      const timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n      let stop = false;\n      let fetchedData = undefined;\n      let satisfied = false;\n      timeoutTimer.start(this.timeout).finally(() => {\n        timeoutTimer.stop();\n        stop = true;\n      });\n\n      while (!stop) {\n        yield periodicTimer.start(this.pollingInterval);\n\n        try {\n          fetchedData = yield doFetch();\n          satisfied = isSatisfied(fetchedData);\n\n          if (satisfied || stop) {\n            break;\n          }\n        } catch (error) {\n          logger_1.Logger.debug(\"TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.\");\n\n          if (!(error instanceof errors_1.Err)) {\n            throw error;\n          }\n        }\n      }\n\n      if (!timeoutTimer.isStopped()) {\n        timeoutTimer.stop();\n      }\n\n      if (!fetchedData || !satisfied) {\n        throw createError();\n      }\n\n      return fetchedData;\n    });\n  }\n\n  getAllTransactionEvents(transaction) {\n    const result = [...transaction.logs.events];\n\n    for (const resultItem of transaction.contractResults.items) {\n      result.push(...resultItem.logs.events);\n    }\n\n    return result;\n  }\n\n}\n\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\n\nTransactionWatcher.NoopOnStatusReceived = _ => {};\n\nclass TransactionFetcherWithTracing {\n  constructor(fetcher) {\n    this.fetcher = fetcher;\n  }\n\n  getTransaction(txHash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger_1.Logger.debug(`transactionWatcher, getTransaction(${txHash})`);\n      return yield this.fetcher.getTransaction(txHash);\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["TransactionWatcher","constructor","fetcher","pollingInterval","DefaultPollingInterval","timeout","DefaultTimeout","TransactionFetcherWithTracing","awaitPending","transaction","isPending","status","doFetch","__awaiter","getTransaction","getHash","hex","errorProvider","errors_1","awaitConditionally","awaitCompleted","isCompleted","transactionOnNetwork","awaitAllEvents","events","foundAllEvents","allEventIdentifiers","getAllTransactionEvents","map","event","identifier","allAreFound","every","includes","awaitAnyEvent","foundAnyEvent","anyIsFound","find","undefined","awaitOnCondition","condition","isSatisfied","createError","periodicTimer","asyncTimer_1","timeoutTimer","stop","fetchedData","satisfied","start","finally","error","logger_1","debug","isStopped","result","logs","resultItem","contractResults","items","push","exports","_","txHash"],"sourceRoot":"","sources":["../src/transactionWatcher.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}