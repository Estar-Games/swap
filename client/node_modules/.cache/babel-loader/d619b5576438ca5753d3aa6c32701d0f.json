{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst collections_1 = require(\"./collections\");\n\nconst types_1 = require(\"./types\"); // TODO: Move to a new file, \"genericOption.ts\"\n\n\nclass OptionType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"Option\", [typeParameter]);\n  }\n\n  getClassName() {\n    return OptionType.ClassName;\n  }\n\n  isAssignableFrom(type) {\n    if (!type.hasExactClass(OptionType.ClassName)) {\n      return false;\n    }\n\n    let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n    let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n    return invariantTypeParameters || fakeCovarianceToNull;\n  }\n\n}\n\nexports.OptionType = OptionType;\nOptionType.ClassName = \"OptionType\"; // TODO: Move to a new file, \"genericList.ts\"\n\nclass ListType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"List\", [typeParameter]);\n  }\n\n  getClassName() {\n    return ListType.ClassName;\n  }\n\n}\n\nexports.ListType = ListType;\nListType.ClassName = \"ListType\"; // TODO: Move to a new file, \"genericOption.ts\"\n\nclass OptionValue extends types_1.TypedValue {\n  constructor(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(type); // TODO: assert value is of type type.getFirstTypeParameter()\n\n    this.value = value;\n  }\n\n  getClassName() {\n    return OptionValue.ClassName;\n  }\n  /**\n   * Creates an OptionValue, as a missing option argument.\n   */\n\n\n  static newMissing() {\n    let type = new OptionType(new types_1.NullType());\n    return new OptionValue(type);\n  }\n\n  static newMissingTyped(type) {\n    return new OptionValue(new OptionType(type));\n  }\n  /**\n   * Creates an OptionValue, as a provided option argument.\n   */\n\n\n  static newProvided(typedValue) {\n    let type = new OptionType(typedValue.getType());\n    return new OptionValue(type, typedValue);\n  }\n\n  isSet() {\n    return this.value ? true : false;\n  }\n\n  getTypedValue() {\n    utils_1.guardValueIsSet(\"value\", this.value);\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value ? this.value.valueOf() : null;\n  }\n\n  equals(other) {\n    var _a;\n\n    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n  }\n\n}\n\nexports.OptionValue = OptionValue;\nOptionValue.ClassName = \"OptionValue\"; // TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\n\nclass List extends types_1.TypedValue {\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  constructor(type, items) {\n    super(type); // TODO: assert items are of type type.getFirstTypeParameter()\n\n    this.backingCollection = new collections_1.CollectionOfTypedValues(items);\n  }\n\n  getClassName() {\n    return List.ClassName;\n  }\n\n  static fromItems(items) {\n    if (items.length == 0) {\n      return new List(new types_1.TypePlaceholder(), []);\n    }\n\n    let typeParameter = items[0].getType();\n    let listType = new ListType(typeParameter);\n    return new List(listType, items);\n  }\n\n  getLength() {\n    return this.backingCollection.getLength();\n  }\n\n  getItems() {\n    return this.backingCollection.getItems();\n  }\n\n  valueOf() {\n    return this.backingCollection.valueOf();\n  }\n\n  equals(other) {\n    return this.backingCollection.equals(other.backingCollection);\n  }\n\n}\n\nexports.List = List;\nList.ClassName = \"List\";","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA,mC,CAEA;;;AACA,MAAaA,UAAb,SAAgCC,YAAhC,CAAoC;EAGhCC,YAAYC,aAAZ,EAA+B;IAC3B,MAAM,QAAN,EAAgB,CAACA,aAAD,CAAhB;EACH;;EAEDC,YAAY;IACR,OAAOJ,UAAU,CAACK,SAAlB;EACH;;EAEDC,gBAAgB,CAACC,IAAD,EAAW;IACvB,IAAI,CAAEA,IAAI,CAACC,aAAL,CAAmBR,UAAU,CAACK,SAA9B,CAAN,EAAiD;MAC7C,OAAO,KAAP;IACH;;IAED,IAAII,uBAAuB,GAAG,KAAKC,qBAAL,GAA6BC,MAA7B,CAAoCJ,IAAI,CAACG,qBAAL,EAApC,CAA9B;IACA,IAAIE,oBAAoB,GAAGL,IAAI,CAACG,qBAAL,GAA6BF,aAA7B,CAA2CP,iBAASI,SAApD,CAA3B;IACA,OAAOI,uBAAuB,IAAIG,oBAAlC;EACH;;AAnB+B;;AAApCC;AACWb,uBAAY,YAAZ,C,CAqBX;;AACA,MAAac,QAAb,SAA8Bb,YAA9B,CAAkC;EAG9BC,YAAYC,aAAZ,EAA+B;IAC3B,MAAM,MAAN,EAAc,CAACA,aAAD,CAAd;EACH;;EAEDC,YAAY;IACR,OAAOU,QAAQ,CAACT,SAAhB;EACH;;AAT6B;;AAAlCQ;AACWC,qBAAY,UAAZ,C,CAWX;;AACA,MAAaC,WAAb,SAAiCd,kBAAjC,CAA2C;EAIvCC,YAAYK,IAAZ,EAA6D;IAAA,IAA/BS,KAA+B,uEAAJ,IAAI;IACzD,MAAMT,IAAN,EADyD,CAGzD;;IAEA,KAAKS,KAAL,GAAaA,KAAb;EACH;;EAEDZ,YAAY;IACR,OAAOW,WAAW,CAACV,SAAnB;EACH;EAED;;;;;EAGiB,OAAVY,UAAU;IACb,IAAIV,IAAI,GAAG,IAAIP,UAAJ,CAAe,IAAIC,gBAAJ,EAAf,CAAX;IACA,OAAO,IAAIc,WAAJ,CAAgBR,IAAhB,CAAP;EACH;;EAEqB,OAAfW,eAAe,CAACX,IAAD,EAAW;IAC7B,OAAO,IAAIQ,WAAJ,CAAgB,IAAIf,UAAJ,CAAeO,IAAf,CAAhB,CAAP;EACH;EAED;;;;;EAGkB,OAAXY,WAAW,CAACC,UAAD,EAAuB;IACrC,IAAIb,IAAI,GAAG,IAAIP,UAAJ,CAAeoB,UAAU,CAACC,OAAX,EAAf,CAAX;IACA,OAAO,IAAIN,WAAJ,CAAgBR,IAAhB,EAAsBa,UAAtB,CAAP;EACH;;EAEDE,KAAK;IACD,OAAO,KAAKN,KAAL,GAAa,IAAb,GAAoB,KAA3B;EACH;;EAEDO,aAAa;IACTC,wBAAgB,OAAhB,EAAyB,KAAKR,KAA9B;IACA,OAAO,KAAKA,KAAZ;EACH;;EAEDS,OAAO;IACH,OAAO,KAAKT,KAAL,GAAa,KAAKA,KAAL,CAAWS,OAAX,EAAb,GAAoC,IAA3C;EACH;;EAEDd,MAAM,CAACe,KAAD,EAAmB;;;IACrB,OAAO,YAAKV,KAAL,MAAU,IAAV,IAAUW,aAAV,GAAU,MAAV,GAAUA,GAAEhB,MAAF,CAASe,KAAK,CAACV,KAAf,CAAV,KAAmC,KAA1C;EACH;;AAnDsC;;AAA3CH;AACWE,wBAAY,aAAZ,C,CAqDX;AACA;AACA;;AACA,MAAaa,IAAb,SAA0B3B,kBAA1B,CAAoC;EAIhC;;;;;EAKAC,YAAYK,IAAZ,EAA4BsB,KAA5B,EAA+C;IAC3C,MAAMtB,IAAN,EAD2C,CAG3C;;IAEA,KAAKuB,iBAAL,GAAyB,IAAIC,qCAAJ,CAA4BF,KAA5B,CAAzB;EACH;;EAEDzB,YAAY;IACR,OAAOwB,IAAI,CAACvB,SAAZ;EACH;;EAEe,OAAT2B,SAAS,CAACH,KAAD,EAAoB;IAChC,IAAIA,KAAK,CAACI,MAAN,IAAgB,CAApB,EAAuB;MACnB,OAAO,IAAIL,IAAJ,CAAS,IAAI3B,uBAAJ,EAAT,EAAgC,EAAhC,CAAP;IACH;;IAED,IAAIE,aAAa,GAAG0B,KAAK,CAAC,CAAD,CAAL,CAASR,OAAT,EAApB;IACA,IAAIa,QAAQ,GAAG,IAAIpB,QAAJ,CAAaX,aAAb,CAAf;IACA,OAAO,IAAIyB,IAAJ,CAASM,QAAT,EAAmBL,KAAnB,CAAP;EACH;;EAEDM,SAAS;IACL,OAAO,KAAKL,iBAAL,CAAuBK,SAAvB,EAAP;EACH;;EAEDC,QAAQ;IACJ,OAAO,KAAKN,iBAAL,CAAuBM,QAAvB,EAAP;EACH;;EAEDX,OAAO;IACH,OAAO,KAAKK,iBAAL,CAAuBL,OAAvB,EAAP;EACH;;EAEDd,MAAM,CAACe,KAAD,EAAY;IACd,OAAO,KAAKI,iBAAL,CAAuBnB,MAAvB,CAA8Be,KAAK,CAACI,iBAApC,CAAP;EACH;;AA7C+B;;AAApCjB;AACWe,iBAAY,MAAZ","names":["OptionType","types_1","constructor","typeParameter","getClassName","ClassName","isAssignableFrom","type","hasExactClass","invariantTypeParameters","getFirstTypeParameter","equals","fakeCovarianceToNull","exports","ListType","OptionValue","value","newMissing","newMissingTyped","newProvided","typedValue","getType","isSet","getTypedValue","utils_1","valueOf","other","_a","List","items","backingCollection","collections_1","fromItems","length","listType","getLength","getItems"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/generic.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}