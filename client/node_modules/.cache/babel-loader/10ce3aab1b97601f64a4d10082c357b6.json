{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\n\nconst codec_1 = require(\"./codec\");\n\nconst composite_1 = require(\"./typesystem/composite\");\n\nconst variadic_1 = require(\"./typesystem/variadic\");\n\nconst algebraic_1 = require(\"./typesystem/algebraic\");\n\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\n\nconst Codec = new codec_1.BinaryCodec();\n\nclass ArgSerializer {\n  /**\n   * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n   */\n  stringToValues(joinedString, parameters) {\n    let buffers = this.stringToBuffers(joinedString);\n    let values = this.buffersToValues(buffers, parameters);\n    return values;\n  }\n  /**\n   * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  stringToBuffers(joinedString) {\n    // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n    return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n  }\n  /**\n   * Decodes a set of buffers into a set of typed values, given parameter definitions.\n   */\n\n\n  buffersToValues(buffers, parameters) {\n    // TODO: Refactor, split (function is quite complex).\n    buffers = buffers || [];\n    let values = [];\n    let bufferIndex = 0;\n    let numBuffers = buffers.length;\n\n    for (let i = 0; i < parameters.length; i++) {\n      let parameter = parameters[i];\n      let type = parameter.type;\n      let value = readValue(type);\n      values.push(value);\n    } // This is a recursive function.\n\n\n    function readValue(type) {\n      // TODO: Use matchers.\n      if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {\n        let typedValue = readValue(type.getFirstTypeParameter());\n        return new algebraic_1.OptionalValue(type, typedValue);\n      } else if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {\n        let typedValues = [];\n\n        while (!hasReachedTheEnd()) {\n          typedValues.push(readValue(type.getFirstTypeParameter()));\n        }\n\n        return new variadic_1.VariadicValue(type, typedValues);\n      } else if (type.hasExactClass(composite_1.CompositeType.ClassName)) {\n        let typedValues = [];\n\n        for (const typeParameter of type.getTypeParameters()) {\n          typedValues.push(readValue(typeParameter));\n        }\n\n        return new composite_1.CompositeValue(type, typedValues);\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let typedValue = decodeNextBuffer(type);\n        return typedValue;\n      }\n    }\n\n    function decodeNextBuffer(type) {\n      if (hasReachedTheEnd()) {\n        return null;\n      }\n\n      let buffer = buffers[bufferIndex++];\n      let decodedValue = Codec.decodeTopLevel(buffer, type);\n      return decodedValue;\n    }\n\n    function hasReachedTheEnd() {\n      return bufferIndex >= numBuffers;\n    }\n\n    return values;\n  }\n  /**\n   * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  valuesToString(values) {\n    let strings = this.valuesToStrings(values);\n    let argumentsString = strings.join(exports.ArgumentsSeparator);\n    let count = strings.length;\n    return {\n      argumentsString,\n      count\n    };\n  }\n  /**\n   * Serializes a set of typed values into a set of strings.\n   */\n\n\n  valuesToStrings(values) {\n    let buffers = this.valuesToBuffers(values);\n    let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n    return strings;\n  }\n  /**\n   * Serializes a set of typed values into a set of strings buffers.\n   * Variadic types and composite types might result into none, one or more buffers.\n   */\n\n\n  valuesToBuffers(values) {\n    // TODO: Refactor, split (function is quite complex).\n    let buffers = [];\n\n    for (const value of values) {\n      handleValue(value);\n    } // This is a recursive function. It appends to the \"buffers\" variable.\n\n\n    function handleValue(value) {\n      // TODO: Use matchers.\n      if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {\n        let valueAsOptional = value;\n\n        if (valueAsOptional.isSet()) {\n          handleValue(valueAsOptional.getTypedValue());\n        }\n      } else if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {\n        let valueAsVariadic = value;\n\n        for (const item of valueAsVariadic.getItems()) {\n          handleValue(item);\n        }\n      } else if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {\n        let valueAsComposite = value;\n\n        for (const item of valueAsComposite.getItems()) {\n          handleValue(item);\n        }\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let buffer = Codec.encodeTopLevel(value);\n        buffers.push(buffer);\n      }\n    }\n\n    return buffers;\n  }\n\n}\n\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"mappings":"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","names":["exports","Codec","codec_1","ArgSerializer","stringToValues","joinedString","parameters","buffers","stringToBuffers","values","buffersToValues","split","map","item","Buffer","from","bufferIndex","numBuffers","length","i","parameter","type","value","readValue","push","hasExactClass","algebraic_1","ClassName","typedValue","getFirstTypeParameter","variadic_1","typedValues","hasReachedTheEnd","composite_1","typeParameter","getTypeParameters","decodeNextBuffer","buffer","decodedValue","decodeTopLevel","valuesToString","strings","valuesToStrings","argumentsString","join","count","valuesToBuffers","toString","handleValue","valueAsOptional","isSet","getTypedValue","valueAsVariadic","getItems","valueAsComposite","encodeTopLevel"],"sourceRoot":"","sources":["../../src/smartcontracts/argSerializer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}