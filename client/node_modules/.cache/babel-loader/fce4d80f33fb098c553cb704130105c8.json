{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResultsParser = void 0;\n\nconst transaction_decoder_1 = require(\"@elrondnetwork/transaction-decoder\");\n\nconst address_1 = require(\"../address\");\n\nconst errors_1 = require(\"../errors\");\n\nconst logger_1 = require(\"../logger\");\n\nconst argSerializer_1 = require(\"./argSerializer\");\n\nconst returnCode_1 = require(\"./returnCode\");\n\nvar WellKnownEvents;\n\n(function (WellKnownEvents) {\n  WellKnownEvents[\"OnTransactionCompleted\"] = \"completedTxEvent\";\n  WellKnownEvents[\"OnSignalError\"] = \"signalError\";\n  WellKnownEvents[\"OnWriteLog\"] = \"writeLog\";\n})(WellKnownEvents || (WellKnownEvents = {}));\n\nvar WellKnownTopics;\n\n(function (WellKnownTopics) {\n  WellKnownTopics[\"TooMuchGas\"] = \"@too much gas provided for processing\";\n})(WellKnownTopics || (WellKnownTopics = {}));\n/**\n * Parses contract query responses and smart contract results.\n * The parsing involves some heuristics, in order to handle slight inconsistencies (e.g. some SCRs are present on API, but missing on Gateway).\n */\n\n\nclass ResultsParser {\n  parseQueryResponse(queryResponse, endpoint) {\n    let parts = queryResponse.getReturnDataParts();\n    let values = new argSerializer_1.ArgSerializer().buffersToValues(parts, endpoint.output);\n    let returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n    return {\n      returnCode: returnCode,\n      returnMessage: queryResponse.returnMessage,\n      values: values,\n      firstValue: values[0],\n      secondValue: values[1],\n      thirdValue: values[2],\n      lastValue: values[values.length - 1]\n    };\n  }\n\n  parseUntypedQueryResponse(queryResponse) {\n    let returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n    return {\n      returnCode: returnCode,\n      returnMessage: queryResponse.returnMessage,\n      values: queryResponse.getReturnDataParts()\n    };\n  }\n\n  parseOutcome(transaction, endpoint) {\n    let untypedBundle = this.parseUntypedOutcome(transaction);\n    let values = new argSerializer_1.ArgSerializer().buffersToValues(untypedBundle.values, endpoint.output);\n    return {\n      returnCode: untypedBundle.returnCode,\n      returnMessage: untypedBundle.returnMessage,\n      values: values,\n      firstValue: values[0],\n      secondValue: values[1],\n      thirdValue: values[2],\n      lastValue: values[values.length - 1]\n    };\n  }\n\n  parseUntypedOutcome(transaction) {\n    let bundle;\n    let transactionMetadata = this.parseTransactionMetadata(transaction);\n    bundle = this.createBundleOnSimpleMoveBalance(transaction);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): on simple move balance\");\n      return bundle;\n    }\n\n    bundle = this.createBundleOnInvalidTransaction(transaction);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): on invalid transaction\");\n      return bundle;\n    }\n\n    bundle = this.createBundleOnEasilyFoundResultWithReturnData(transaction.contractResults);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): on easily found result with return data\");\n      return bundle;\n    }\n\n    bundle = this.createBundleOnSignalError(transaction.logs);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): on signal error\");\n      return bundle;\n    }\n\n    bundle = this.createBundleOnTooMuchGasWarning(transaction.logs);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): on 'too much gas' warning\");\n      return bundle;\n    }\n\n    bundle = this.createBundleOnWriteLogWhereFirstTopicEqualsAddress(transaction.logs, transaction.sender);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): on writelog with topics[0] == tx.sender\");\n      return bundle;\n    }\n\n    bundle = this.createBundleWithCustomHeuristics(transaction, transactionMetadata);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): with custom heuristics\");\n      return bundle;\n    }\n\n    bundle = this.createBundleWithFallbackHeuristics(transaction, transactionMetadata);\n\n    if (bundle) {\n      logger_1.Logger.trace(\"parseUntypedOutcome(): with fallback heuristics\");\n      return bundle;\n    }\n\n    throw new errors_1.ErrCannotParseContractResults(`transaction ${transaction.hash.toString()}`);\n  }\n\n  parseTransactionMetadata(transaction) {\n    return new transaction_decoder_1.TransactionDecoder().getTransactionMetadata({\n      sender: transaction.sender.bech32(),\n      receiver: transaction.receiver.bech32(),\n      data: transaction.data.toString(\"base64\"),\n      value: transaction.value.toString(),\n      type: transaction.type\n    });\n  }\n\n  createBundleOnSimpleMoveBalance(transaction) {\n    let noResults = transaction.contractResults.items.length == 0;\n    let noLogs = transaction.logs.events.length == 0;\n\n    if (noResults && noLogs) {\n      return {\n        returnCode: returnCode_1.ReturnCode.None,\n        returnMessage: returnCode_1.ReturnCode.None.toString(),\n        values: []\n      };\n    }\n\n    return null;\n  }\n\n  createBundleOnInvalidTransaction(transaction) {\n    if (transaction.status.isInvalid()) {\n      if (transaction.receipt.data) {\n        return {\n          returnCode: returnCode_1.ReturnCode.OutOfFunds,\n          returnMessage: transaction.receipt.data,\n          values: []\n        };\n      } // If there's no receipt message, let other heuristics to handle the outcome (most probably, a log with \"signalError\" is emitted).\n\n    }\n\n    return null;\n  }\n\n  createBundleOnEasilyFoundResultWithReturnData(results) {\n    let resultItemWithReturnData = results.items.find(item => item.nonce.valueOf() != 0 && item.data.startsWith(\"@\"));\n\n    if (!resultItemWithReturnData) {\n      return null;\n    }\n\n    let {\n      returnCode,\n      returnDataParts\n    } = this.sliceDataFieldInParts(resultItemWithReturnData.data);\n    let returnMessage = resultItemWithReturnData.returnMessage || returnCode.toString();\n    return {\n      returnCode: returnCode,\n      returnMessage: returnMessage,\n      values: returnDataParts\n    };\n  }\n\n  createBundleOnSignalError(logs) {\n    let eventSignalError = logs.findSingleOrNoneEvent(WellKnownEvents.OnSignalError);\n\n    if (!eventSignalError) {\n      return null;\n    }\n\n    let {\n      returnCode,\n      returnDataParts\n    } = this.sliceDataFieldInParts(eventSignalError.data);\n    let lastTopic = eventSignalError.getLastTopic();\n    let returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n    return {\n      returnCode: returnCode,\n      returnMessage: returnMessage,\n      values: returnDataParts\n    };\n  }\n\n  createBundleOnTooMuchGasWarning(logs) {\n    let eventTooMuchGas = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, event => event.findFirstOrNoneTopic(topic => topic.toString().startsWith(WellKnownTopics.TooMuchGas)) != undefined);\n\n    if (!eventTooMuchGas) {\n      return null;\n    }\n\n    let {\n      returnCode,\n      returnDataParts\n    } = this.sliceDataFieldInParts(eventTooMuchGas.data);\n    let lastTopic = eventTooMuchGas.getLastTopic();\n    let returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n    return {\n      returnCode: returnCode,\n      returnMessage: returnMessage,\n      values: returnDataParts\n    };\n  }\n\n  createBundleOnWriteLogWhereFirstTopicEqualsAddress(logs, address) {\n    let hexAddress = new address_1.Address(address.bech32()).hex();\n    let eventWriteLogWhereTopicIsSender = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, event => event.findFirstOrNoneTopic(topic => topic.hex() == hexAddress) != undefined);\n\n    if (!eventWriteLogWhereTopicIsSender) {\n      return null;\n    }\n\n    let {\n      returnCode,\n      returnDataParts\n    } = this.sliceDataFieldInParts(eventWriteLogWhereTopicIsSender.data);\n    let returnMessage = returnCode.toString();\n    return {\n      returnCode: returnCode,\n      returnMessage: returnMessage,\n      values: returnDataParts\n    };\n  }\n  /**\n   * Override this method (in a subclass of {@link ResultsParser}) if the basic heuristics of the parser are not sufficient.\n   */\n\n\n  createBundleWithCustomHeuristics(_transaction, _transactionMetadata) {\n    return null;\n  }\n\n  createBundleWithFallbackHeuristics(transaction, transactionMetadata) {\n    let contractAddress = new address_1.Address(transactionMetadata.receiver); // Search the nested logs for matching events (writeLog):\n\n    for (const resultItem of transaction.contractResults.items) {\n      let writeLogWithReturnData = resultItem.logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, event => {\n        var _a;\n\n        let addressIsSender = event.address.bech32() == transaction.sender.bech32();\n        let firstTopicIsContract = ((_a = event.topics[0]) === null || _a === void 0 ? void 0 : _a.hex()) == contractAddress.hex();\n        return addressIsSender && firstTopicIsContract;\n      });\n\n      if (writeLogWithReturnData) {\n        let {\n          returnCode,\n          returnDataParts\n        } = this.sliceDataFieldInParts(writeLogWithReturnData.data);\n        let returnMessage = returnCode.toString();\n        return {\n          returnCode: returnCode,\n          returnMessage: returnMessage,\n          values: returnDataParts\n        };\n      }\n    }\n\n    return null;\n  }\n\n  sliceDataFieldInParts(data) {\n    // By default, skip the first part, which is usually empty (e.g. \"[empty]@6f6b\")\n    let startingIndex = 1; // Before trying to parse the hex strings, cut the unwanted parts of the data field, in case of token transfers:\n\n    if (data.startsWith(\"ESDTTransfer\")) {\n      // Skip \"ESDTTransfer\" (1), token identifier (2), amount (3)\n      startingIndex = 3;\n    } else {// TODO: Upon gathering more transaction samples, fix for other kinds of transfers, as well (future PR, as needed).\n    }\n\n    let parts = new argSerializer_1.ArgSerializer().stringToBuffers(data);\n    let returnCodePart = parts[startingIndex] || Buffer.from([]);\n    let returnDataParts = parts.slice(startingIndex + 1);\n\n    if (returnCodePart.length == 0) {\n      throw new errors_1.ErrCannotParseContractResults(\"no return code\");\n    }\n\n    let returnCode = returnCode_1.ReturnCode.fromBuffer(returnCodePart);\n    return {\n      returnCode,\n      returnDataParts\n    };\n  }\n\n}\n\nexports.ResultsParser = ResultsParser;","map":{"version":3,"mappings":"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","names":["WellKnownEvents","WellKnownTopics","ResultsParser","parseQueryResponse","queryResponse","endpoint","parts","getReturnDataParts","values","argSerializer_1","buffersToValues","output","returnCode","returnCode_1","toString","returnMessage","firstValue","secondValue","thirdValue","lastValue","length","parseUntypedQueryResponse","parseOutcome","transaction","untypedBundle","parseUntypedOutcome","bundle","transactionMetadata","parseTransactionMetadata","createBundleOnSimpleMoveBalance","logger_1","trace","createBundleOnInvalidTransaction","createBundleOnEasilyFoundResultWithReturnData","contractResults","createBundleOnSignalError","logs","createBundleOnTooMuchGasWarning","createBundleOnWriteLogWhereFirstTopicEqualsAddress","sender","createBundleWithCustomHeuristics","createBundleWithFallbackHeuristics","errors_1","hash","transaction_decoder_1","getTransactionMetadata","bech32","receiver","data","value","type","noResults","items","noLogs","events","None","status","isInvalid","receipt","OutOfFunds","results","resultItemWithReturnData","find","item","nonce","valueOf","startsWith","returnDataParts","sliceDataFieldInParts","eventSignalError","findSingleOrNoneEvent","OnSignalError","lastTopic","getLastTopic","eventTooMuchGas","OnWriteLog","event","findFirstOrNoneTopic","topic","TooMuchGas","undefined","address","hexAddress","address_1","hex","eventWriteLogWhereTopicIsSender","_transaction","_transactionMetadata","contractAddress","resultItem","writeLogWithReturnData","addressIsSender","firstTopicIsContract","topics","_a","startingIndex","stringToBuffers","returnCodePart","Buffer","from","slice","fromBuffer","exports"],"sourceRoot":"","sources":["../../src/smartcontracts/resultsParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}