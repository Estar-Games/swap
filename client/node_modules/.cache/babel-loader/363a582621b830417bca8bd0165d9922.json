{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OptionalValue = exports.OptionalType = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst types_1 = require(\"./types\");\n/**\n * An optional is an algebraic type. It holds zero or one values.\n */\n\n\nclass OptionalType extends types_1.Type {\n  constructor(typeParameter) {\n    super(\"Optional\", [typeParameter], types_1.TypeCardinality.variable(1));\n  }\n\n  getClassName() {\n    return OptionalType.ClassName;\n  }\n\n  isAssignableFrom(type) {\n    if (!type.hasExactClass(OptionalType.ClassName)) {\n      return false;\n    }\n\n    let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n    let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n    return invariantTypeParameters || fakeCovarianceToNull;\n  }\n\n}\n\nexports.OptionalType = OptionalType;\nOptionalType.ClassName = \"OptionalType\";\n\nclass OptionalValue extends types_1.TypedValue {\n  constructor(type) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(type); // TODO: assert value is of type type.getFirstTypeParameter()\n\n    this.value = value;\n  }\n\n  getClassName() {\n    return OptionalValue.ClassName;\n  }\n  /**\n   * Creates an OptionalValue, as not provided (missing).\n   */\n\n\n  static newMissing() {\n    let type = new OptionalType(new types_1.NullType());\n    return new OptionalValue(type);\n  }\n\n  isSet() {\n    return this.value ? true : false;\n  }\n\n  getTypedValue() {\n    utils_1.guardValueIsSet(\"value\", this.value);\n    return this.value;\n  }\n\n  valueOf() {\n    return this.value ? this.value.valueOf() : null;\n  }\n\n  equals(other) {\n    var _a;\n\n    return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n  }\n\n}\n\nexports.OptionalValue = OptionalValue;\nOptionalValue.ClassName = \"OptionalValue\";","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;AAEA;;;;;AAGA,MAAaA,YAAb,SAAkCC,YAAlC,CAAsC;EAGlCC,YAAYC,aAAZ,EAA+B;IAC3B,MAAM,UAAN,EAAkB,CAACA,aAAD,CAAlB,EAAmCF,wBAAgBG,QAAhB,CAAyB,CAAzB,CAAnC;EACH;;EAEDC,YAAY;IACR,OAAOL,YAAY,CAACM,SAApB;EACH;;EAEDC,gBAAgB,CAACC,IAAD,EAAW;IACvB,IAAI,CAAEA,IAAI,CAACC,aAAL,CAAmBT,YAAY,CAACM,SAAhC,CAAN,EAAmD;MAC/C,OAAO,KAAP;IACH;;IAED,IAAII,uBAAuB,GAAG,KAAKC,qBAAL,GAA6BC,MAA7B,CAAoCJ,IAAI,CAACG,qBAAL,EAApC,CAA9B;IACA,IAAIE,oBAAoB,GAAGL,IAAI,CAACG,qBAAL,GAA6BF,aAA7B,CAA2CR,iBAASK,SAApD,CAA3B;IACA,OAAOI,uBAAuB,IAAIG,oBAAlC;EACH;;AAnBiC;;AAAtCC;AACWd,yBAAY,cAAZ;;AAqBX,MAAae,aAAb,SAAmCd,kBAAnC,CAA6C;EAIzCC,YAAYM,IAAZ,EAA+D;IAAA,IAA/BQ,KAA+B,uEAAJ,IAAI;IAC3D,MAAMR,IAAN,EAD2D,CAG3D;;IAEA,KAAKQ,KAAL,GAAaA,KAAb;EACH;;EAEDX,YAAY;IACR,OAAOU,aAAa,CAACT,SAArB;EACH;EAED;;;;;EAGiB,OAAVW,UAAU;IACb,IAAIT,IAAI,GAAG,IAAIR,YAAJ,CAAiB,IAAIC,gBAAJ,EAAjB,CAAX;IACA,OAAO,IAAIc,aAAJ,CAAkBP,IAAlB,CAAP;EACH;;EAEDU,KAAK;IACD,OAAO,KAAKF,KAAL,GAAa,IAAb,GAAoB,KAA3B;EACH;;EAEDG,aAAa;IACTC,wBAAgB,OAAhB,EAAyB,KAAKJ,KAA9B;IACA,OAAO,KAAKA,KAAZ;EACH;;EAEDK,OAAO;IACH,OAAO,KAAKL,KAAL,GAAa,KAAKA,KAAL,CAAWK,OAAX,EAAb,GAAoC,IAA3C;EACH;;EAEDT,MAAM,CAACU,KAAD,EAAqB;;;IACvB,OAAO,YAAKN,KAAL,MAAU,IAAV,IAAUO,aAAV,GAAU,MAAV,GAAUA,GAAEX,MAAF,CAASU,KAAK,CAACN,KAAf,CAAV,KAAmC,KAA1C;EACH;;AAvCwC;;AAA7CF;AACWC,0BAAY,eAAZ","names":["OptionalType","types_1","constructor","typeParameter","variable","getClassName","ClassName","isAssignableFrom","type","hasExactClass","invariantTypeParameters","getFirstTypeParameter","equals","fakeCovarianceToNull","exports","OptionalValue","value","newMissing","isSet","getTypedValue","utils_1","valueOf","other","_a"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/algebraic.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}